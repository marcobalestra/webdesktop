const existingStorages=()=>{const out=[];return window.sessionStorage.getItem("mabro")&&out.push("session"),window.localStorage.getItem("mabro")&&out.push("local"),out},string2arraybuffer=str=>{let encoder=new TextEncoder("utf-8");return encoder.encode(str)},arraybuffer2string=buffer=>{let decoder=new TextDecoder("utf-8");return decoder.decode(buffer)},VAULT=class{#prop;constructor(password){this.#prop={password:password||"",key_object:null,vector:window.crypto.getRandomValues(new Uint8Array(16))}}async getKey(){if(this.#prop.key_object)return this.#prop.key_object;if(!this.#prop.password)return!1;var password=string2arraybuffer(this.#prop.password),pepper=string2arraybuffer("Â¡Hasta la victoria siempre!");try{var importedPassword=await window.crypto.subtle.importKey("raw",password,{name:"PBKDF2"},!1,["deriveKey"]);this.#prop.key_object=await window.crypto.subtle.deriveKey({name:"PBKDF2",salt:pepper,iterations:1e5,hash:"SHA-256"},importedPassword,{name:"AES-GCM",length:128},!1,["encrypt","decrypt"])}catch(e){console.log("Error while importing key: "+e.message)}return this.#prop.key_object}setPassword(password){this.#prop.password=password,this.#prop.key_object=null}async isEncrypted(){return!(!this.#prop.password||!await this.getKey())}async encrypt(data){var key_object=await this.getKey();return"object"==typeof data&&(data=JSON.stringify(data)),data=key_object?(data=string2arraybuffer(data),data=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:this.#prop.vector},key_object,data),data=arraybuffer2string(data),window.encodeURIComponent(data)):window.btoa(window.encodeURIComponent(data))}async decrypt(data){var key_object=await this.getKey();if(key_object){data=window.decodeURIComponent(data);try{data=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:this.#prop.vector},key_object,data)}catch(e){return console.log("vault decrypt",e),{error:"decrypt",message:e.message}}data=arraybuffer2string(data)}else data=window.decodeURIComponent(window.atob(data));return JSON.parse(data)}},getClass=async mb=>{return class{#prop;#storage;#data;#vault;constructor(manifest){this.#prop={},this.#prop.manifest=manifest,this.#prop.mb=mb,this.#prop.myuri=manifest.base_uri,this.#vault=new VAULT}async boot(){mb.plugin("fs-starter",{cancancel:!1,autostart:!0})}async init(idata){"local"===(idata="object"!=typeof idata?{mode:"local"}:idata).mode?this.#storage=window.localStorage:this.#storage=window.sessionStorage,idata.password&&this.#vault.setPassword(idata.password),this.#storage.getItem("mabro")?this.#data=await this.#vault.decrypt(this.#storage.getItem("mabro")):(idata.profile||(idata.profile="skeleton"),this.#data=await glob.get(this.#prop.myuri+idata.profile+".json"),this.commit())}apps(refresh){if(refresh){const apps=[],appshash=this.#prop.mb.apps();Object.keys(appshash).forEach(k=>{appshash[k].system||apps.push(k)}),this.#data.apps=apps,this.commit()}return JSON.parse(JSON.stringify(this.#data.apps))}commit(force){this.#prop.commitTimeout&&(window.clearTimeout(this.#prop.commitTimeout),delete this.#prop.commitTimeout),force?this.#vault.encrypt(this.#data).then(enc=>{this.#storage.setItem("mabro",enc),this.#vault.isEncrypted().then(isE=>{isE?this.#storage.setItem("mabro-encrypted","true"):this.#storage.getItem("mabro-encrypted")&&this.#storage.removeItem("mabro-encrypted")})}):this.#prop.commitTimeout=window.setTimeout(()=>{this.commit(!0)},2e3)}existingStorages(){return existingStorages()}getDir(id){let d=this.#data.dirs[id];if(d)return d=JSON.parse(JSON.stringify(d)),d.id=id,d}setDir(id){if(id.id&&id.name){let d=JSON.parse(JSON.stringify(id));id=d.id;delete d.id,this.#data.dirs[id]=d,this.commit()}}rmDir(id){"object"==typeof id&&id.id&&(id=id.id);let data=this.#data.dirs[id];"object"==typeof data&&(Array.isArray(data.dirs)&&data.dirs.forEach(sd=>{this.rmDir(sd)}),Array.isArray(data.files)&&data.files.forEach(f=>{this.rmFile(f)}),data.parent&&(this.#data.dirs[data.parent].dirs=this.#data.dirs[data.parent].dirs.filter(x=>x!==id)),delete this.#data.dirs[id],this.commit())}rmFile(id){"object"==typeof id&&id.id&&(id=id.id);var data=this.#data.files[id];"object"==typeof data&&(data.parent&&(this.#data.dirs[data.parent].files=this.#data.dirs[data.parent].files.filter(x=>x!==id)),delete this.#data.files[id],this.commit())}getRoot(){return this.getDir(this.#data.root)}getTrash(){return this.getDir(this.#data.trash)}listAncestors(o,list){void 0===list?list=[]:list.push(o);o=this.#data.dirs[o];return o.parent?this.listAncestors(o.parent,list):list}dump(){console.log(this.#data)}}};export default getClass;